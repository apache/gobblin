package com.linkedin.uif.source.extractor.extract.sftp;

<<<<<<< HEAD
=======
import java.io.IOException;
import java.io.InputStream;
import java.util.Iterator;
import java.util.List;

import com.jcraft.jsch.JSchException;
import com.jcraft.jsch.Session;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.jcraft.jsch.ChannelSftp;
import com.jcraft.jsch.SftpException;
import com.linkedin.uif.configuration.ConfigurationKeys;
>>>>>>> a15109ea2ce90fb443c1cc543744c9bf05a97958
import com.linkedin.uif.configuration.WorkUnitState;
import com.linkedin.uif.source.extractor.filebased.FileBasedExtractor;

/**
 * Abstract class that implements the SFTP
 * protocol for connecting to source
 * and downloading files
 * @author stakiar
 */
public class SftpExtractor<S, D> extends FileBasedExtractor<S, D>
{
<<<<<<< HEAD
    public SftpExtractor(WorkUnitState workUnitState)
    {
        super(workUnitState, new SftpFsHelper(workUnitState));
=======
    private static final Logger log = LoggerFactory.getLogger(SftpExtractor.class);

    private Session session;
    private ChannelSftp channelSftp;
    private SftpExecutor executor;
    
    public SftpExtractor(WorkUnitState workUnitState)
    {
        super(workUnitState);
        createSftpConnection();
        this.executor = new SftpExecutor();
    }
    
    /**
     * Initializes the ChannelSftp
     * @return the ChannelSftp connection
     */
    public void createSftpConnection() {
        this.session = SftpExecutor.connect(this.workUnitState.getProp(ConfigurationKeys.SOURCE_CONN_PRIVATE_KEY),
                                                              this.workUnitState.getProp(ConfigurationKeys.SOURCE_CONN_KNOWN_HOSTS),
                                                              this.workUnitState.getProp(ConfigurationKeys.SOURCE_CONN_USERNAME),
                                                              this.workUnitState.getProp(ConfigurationKeys.SOURCE_CONN_HOST_NAME),
                                                              this.workUnitState.getProp(ConfigurationKeys.SOURCE_CONN_USE_PROXY_URL),
                                                              this.workUnitState.getPropAsInt(ConfigurationKeys.SOURCE_CONN_USE_PROXY_PORT, -1),
							      this.workUnitState.getPropAsInt(ConfigurationKeys.SOURCE_CONN_PORT, 22));

        try {
            log.info("Establishing a SFTP channel");
            this.channelSftp = (ChannelSftp) this.session.openChannel("sftp");
            this.channelSftp.connect();
        } catch (JSchException je) {
            log.error("Failed to establish a SFTP channel", je);
            throw new RuntimeException(je);
        }
    }

    /**
     * Gets the max watermark
     * @return the max watermark
     */
    @Override
    public long getMaxWatermark(String schema, String entity, String watermarkColumn, List<Predicate> snapshotPredicateList, String watermarkSourceFormat) throws HighWatermarkException
    {
        log.info("Getting max watermark");
        List<Command> cmds = this.getHighWatermarkMetadata(schema, entity, watermarkColumn, snapshotPredicateList);
        try {
            CommandOutput<SftpCommand, List<String>> response = SftpExecutor.executeUnixCommands(cmds, this.channelSftp);
            return this.getHighWatermark(response, watermarkColumn, watermarkSourceFormat);
        }
        catch (SftpException e)
        {
            throw new HighWatermarkException("SftpException while getting maxWatermark: " + e.getMessage(), e);
        }
        catch (SftpCommandFormatException e)
        {
            throw new HighWatermarkException("SftpCommandFormatException whilte getting maxWatermark: " + e.getMessage(), e);
        }  
    }

    /**
     * Gets the metadata for this job (e.g. the schema)
     */
    @Override
    public void extractMetadata(String schema, String entity, WorkUnit workUnit) throws SchemaException, IOException
    {
        log.info("Getting the schema");
        List<Command> cmds = this.getSchemaMetadata(schema, entity);
        try
        {
            CommandOutput<SftpCommand, List<String>> response = SftpExecutor.executeUnixCommands(cmds, this.channelSftp);
            String array = this.getSchema(response);
            this.setOutputSchema(array);
        }
        catch (SftpException e)
        {
            throw new SchemaException("SftpException while getting schema: " + e.getMessage(), e);
        }
        catch (SftpCommandFormatException e)
        {
            throw new SchemaException("SftpCommandFormatException while getting schema: " + e.getMessage(), e);
        }        
    }
    
    /**
     * Downloads the file from the source and returns it as an iterator
     */
    @SuppressWarnings("unchecked")
    @Override
    public Iterator<String> getRecordSet(String schema, String entity, WorkUnit workUnit, List<Predicate> predicateList) throws DataRecordException, IOException
    {
        try
        {
            log.info("Fetching record set");
            List<Command> cmds = this.getDataMetadata(schema, entity, workUnit, predicateList);
            if (cmds == null || cmds.isEmpty()) {
                return null;
            }
            for (Command cmd : cmds) {
                if (cmd instanceof SftpCommand) {
                    SftpCommand sftpCmd = (SftpCommand) cmd;
                    if (sftpCmd.getCommandType().equals(SftpCommandType.GET_FILE)) {
                        executor.executeGetFileCommand(sftpCmd, this.channelSftp, this.workUnit.getProp(ConfigurationKeys.WRITER_FILE_SYSTEM_URI));
                    } else if (sftpCmd.getCommandType().equals(SftpCommandType.GET_STREAM)) {
                        InputStream stream = executor.executeGetStreamCommand(sftpCmd, this.channelSftp);
                        CommandOutput<SftpCommand, InputStream> getStreamOutput = new SftpGetCommandOuput();
                        getStreamOutput.put(sftpCmd, stream);
                        return this.getData(getStreamOutput);
                    } else {
                        SftpExecutor.executeUnixCommand(sftpCmd, this.channelSftp);
                    }
                } else {
                    throw new DataRecordException("Illegal command given to getRecordSet()");
                }
            }
            return this.getData(new SftpCommandOutput());
        } catch (SftpException e) {
            throw new DataRecordException(e.getMessage(),  e);
        } catch (SftpCommandFormatException e) {
            throw new DataRecordException(e.getMessage(), e);
        }
    }
    
    /**
     * Gets the count of the files
     * 
     * TODO this can be implemented using the
     * ChannelSftp.stat(path) command (not
     * applicable for Responsys since the files
     * on the server are encrypted)
     * 
     * TODO this only supports downloading
     * of not file, not multiple files
     * 
     * @return the count of the files to download
     */
    @Override
    public long getSourceCount(String schema,
                               String entity,
                               WorkUnit workUnit,
                               List<Predicate> predicateList) throws RecordCountException
    {
        return -1;
    }
    
    /**
     * Close ChannelSftp connection
     */
    @Override
    public void closeConnection() throws Exception
    {
        log.info("Shutting down the sftp connection");
        try {
            this.channelSftp.disconnect();
        } catch (Throwable t) {
            log.error("Failed to disconnect the SFTP channel", t);
        }
        this.session.disconnect();
>>>>>>> a15109ea2ce90fb443c1cc543744c9bf05a97958
    }
}
